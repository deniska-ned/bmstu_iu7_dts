# Отчёт по Лабораторной работе №6 "Обработка деревьев и хеш функций"

Вариант: 3

Студент: **Недолужко Денис**

Группа: **ИУ7-33Б**

Год: 2020

## Описание условия задачи

Цель работы – получить навыки применения двоичных деревьев,
реализовать основные операции над деревьями: обход деревьев, включение,
исключение и поиск узлов; построить и обработать хеш-таблицы, сравнить
эффективность поиска в сбалансированных деревьях, в двоичных деревьях
поиска и в хеш-таблицах.

## Описание ТЗ

### Описание задачи

В текстовом файле содержатся целые числа. Построить ДДП из чисел файла.
Вывести его на экран в виде дерева. Сбалансировать полученное дерево и
вывести его на экран. Построить хеш-таблицу из чисел файла. Использовать
закрытое хеширование для устранения коллизий. Осуществить добавление
введённого целого числа, если его там нет, в ДДП, в сбалансированное дерево, в
хеш-таблицу и в файл. Сравнить время добавления, объем памяти и количество
сравнений при использовании различных (4-х) структур данных. Если количество
сравнений в хеш-таблице больше указанного (вводить), то произвести
реструктуризацию таблицы, выбрав другую функцию.

### Входные данные

Пользователю выводится меню, где можно выбрать работу с двоичным деревом
поиска, АВЛ деревом, хеш таблицей и файлом, а так же вывод статистики по
используемой памяти и времени выполнения алгоритмов вставки и поиска.

### Выходные данные

Состояние ДДП, АВЛ, хеш-таблицы, файла, результаты их обработки.

### Способ обращения к программе

Запускается в терминале командой `./app.exe` в папке с программой.

### Описание возможных аварийных ситуаций

Некорректный ввод пользователя. Сообщение `Некорректный ввод`.
Невозможность выделения памяти под переменные `Невозможно выделить память под
переменную`
Переполнение хеш-таблицы `Таблица переполнена`

## Описание внутренний структур данных

```c
typedef struct tree_classic_node tc_node_t;

struct tree_classic_node
{
    elem_t data;
    tc_node_t *left;
    tc_node_t *right;
};
```

Узел ДДП

* data - Хранимое число
* right - указатель на правое поддерево
* left - указатель на левое поддерево

---

```c
typedef struct tree_balance_node tb_node_t;

struct tree_balance_node
{
    elem_t data;
    unsigned height;
    tb_node_t *right;
    tb_node_t *left;
};
```

Узел АВЛ дерева

* data - Хранимое число
* height - Высота поддерева
* right - указатель на правое поддерево
* left - указатель на левое поддерево

---

```c
typedef enum HASH_TABLE_ITEM_STATUS
{
    DELETED = -1,
    EMPTY   =  0,
    USE     =  1
} hash_item_status_t;

typedef struct
{
    elem_t elem;
    hash_item_status_t item_status;
} hash_table_item_t;

typedef struct
{
    hash_table_item_t *data;
    size_t len;
    hash_func_t hash_func;
} hash_table_t;
```

Структуры данных для работы с хеш таблицей

* `hash_item_status_t` - статус ячейки в таблице
* `hash_table_item_t` - ячейка в таблице
* `hash_table_t` - таблица

* elem - Хранимое число
* data - указатель массив с данными
* len - количество элементов в таблице
* hash\_func - хеш функция, используемая в таблице

## Описание функций

Добавление, поиск и удаление из ДДП

```c
int tree_add_elem(tc_node_t **root, elem_t elem);
bool tree_is_elem_found(tc_node_t *root, elem_t elem, size_t *comparisons);
void tree_del_elem(tc_node_t **root, elem_t elem);
```

Добавление, поиск и удаление из АВЛ дерева

```c
int btree_add(tb_node_t **root, elem_t elem);
bool btree_is_elem_found(tb_node_t *root, elem_t elem, size_t *comparisons);
void btree_del(tb_node_t **root, elem_t elem);
```

Добавление, поиск и удаление из хеш таблицы

```c
int hash_table_add(hash_table_t *table, elem_t elem);
bool hash_table_is_elem_found(hash_table_t *table, elem_t elem, size_t *comparisons);
void hash_table_del(hash_table_t *table, elem_t elem);
```

Добавление, поиск и удаление из файла

```c
int file_add(char *file_name, elem_t elem);
int file_search(char *file_name, elem_t elem, size_t *comparisons, int *find);
int file_del(char *file_name, elem_t key);
```

Экспортирование ДДП и АВЛ дерева в изображение

```c
int tree_export_to_dot(tc_node_t *root, char *file_dst, char *tree_name);
int btree_export_to_dot(tb_node_t *root, char *file_dst, char *tree_name);
```

## Результаты измерений

Максимальное среднее число сравнений в хеш таблице: 3

|  Тип данных  | Кол-во эл. | Добавление | Поиск       | Число сравнений | Память  |
|--------------|------------|------------|-------------|-----------------|---------|
| ДДП          |        200 |      56845 |       31903 |           10.55 |    4800 |
| АВЛ          |        200 |     138196 |       28216 |            6.88 |    6400 |
| Хеш таблица  |        200 |      11766 |       24785 |            2.90 |    3592 |
| Файл         |        200 |    9504819 |     8062004 |          100.50 |     224 |
| ДДП          |        300 |      73699 |       41803 |            8.65 |    7200 |
| АВЛ          |        300 |     185978 |       40893 |            7.47 |    9600 |
| Хеш таблица  |        300 |      12101 |       27089 |            2.71 |    5576 |
| Файл         |        300 |   19346452 |    14649139 |          150.50 |     224 |
| ДДП          |        400 |      91439 |       53223 |           10.47 |    9600 |
| АВЛ          |        400 |     230153 |       71366 |            7.88 |   12800 |
| Хеш таблица  |        400 |      17235 |       39671 |            2.81 |    7336 |
| Файл         |        400 |   27647554 |    22118435 |          200.50 |     224 |
| ДДП          |        500 |     109713 |       65120 |           10.17 |   12000 |
| АВЛ          |        500 |     273620 |       61279 |            8.18 |   16000 |
| Хеш таблица  |        500 |      20600 |       42973 |            2.99 |    9608 |
| Файл         |        500 |   39042788 |    32433766 |          250.50 |     224 |
| ДДП          |        600 |     131543 |       81087 |           10.69 |   14400 |
| АВЛ          |        600 |     359302 |       76241 |            8.51 |   19200 |
| Хеш таблица  |        600 |      24464 |       52586 |            2.99 |   11848 |
| Файл         |        600 |   53066924 |    45455980 |          300.50 |     224 |
| ДДП          |        700 |     156193 |       96675 |           11.14 |   16800 |
| АВЛ          |        700 |     398632 |       90620 |            8.64 |   22400 |
| Хеш таблица  |        700 |      29592 |       63865 |            2.98 |   13288 |
| Файл         |        700 |   69763689 |    61258979 |          350.50 |     224 |
| ДДП          |        800 |     189048 |      114735 |           11.15 |   19200 |
| АВЛ          |        800 |     514374 |      107528 |            8.88 |   25600 |
| Хеш таблица  |        800 |      33260 |       70903 |            2.96 |   14888 |
| Файл         |        800 |   94675410 |    79109881 |          400.50 |     224 |
| ДДП          |        900 |     228795 |      141598 |           14.06 |   21600 |
| АВЛ          |        900 |     531243 |      125330 |            9.03 |   28800 |
| Хеш таблица  |        900 |      36795 |       78707 |            2.84 |   17480 |
| Файл         |        900 |  113814058 |   100528157 |          450.50 |     224 |
| ДДП          |       1000 |     235599 |      148951 |           12.11 |   24000 |
| АВЛ          |       1000 |     606830 |      139913 |            9.17 |   32000 |
| Хеш таблица  |       1000 |      48555 |      121264 |            2.80 |   19240 |
| Файл         |       1000 |  158807741 |   123732864 |          500.50 |     224 |

Время изменяется в тактах, память в байтах

### Анализ результатов

Так как файл содержит неупорядоченные числа, то среднее число сравнений для
поиска нужного значения в среднем составляет половину от общего числа элементов
в нем. Время работы алгоритмов поиска и вставки на несколько порядков больше
чем время в деревьях и хеш таблице.

Добавление в АВЛ дерево происходит в 2-3 раза медленнее, чем добавление в ДДП,
из необходимости проводить балансировку. Добавление же в хеш таблицу происходит
в 5-9 раз быстрее чем в ДДП, так как среднее число сравнений в 6 раз меньше.

Поиск в АВЛ дереве происходит быстрее, чем в ДДП, так как у него высота меньше.
Поиск в хеш таблице происходит быстрее чем в АВЛ дереве, так как как меньше
число сравнений.

При правильно подобранной хеш функции, хеш таблица весит меньше, чем деревья,
так как каждый её элемент не хранит указатели на потомков (так как их нет).
АВЛ дерево весит больше ДДП, потому что оно хранит данных для проведения
балансировки.

## Вывод

Хеш таблица при хорошо подобранной хеш функции выигрывает у деревьев и по
памяти(на 33% у АВЛ дерева, и на 20% у ДДП), необходимой для хранения,
и по времени выполнения алгоритмов добавления (в 15 раз быстрее, чем у АВЛ,
в 6 раз быстрее чем у ДДП)
и поиска(в 2 раза быстрее, чем ДДП, в 1.7 раз быстрее, чем в АВЛ).
Однако если среднее число сравнений будет расти, то она потеряет
свои преимущества и придётся проводить реструктуризацию таблицы, поменяв
функцию или увеличив размер таблицы.

АВЛ дерево занимает больше памяти (на 33%) и требует больше времени на добавление
элементов(в 2-3 раза), чем ДДП. Однако время поиск в нем меньше (на 12%),
чем в ДДП.

Хранить данные в файле сильно невыгодно, так как время добавление и поиска
элементов в несколько порядков больше, чем в деревьях или хеш таблице. Однако
файл не хранит свои значения в оперативной памяти, что может быть полезно при
работе с данными, размер которых соизмерим с оперативной памятью компьютера,
однако время выполнения будет очень большим.

## Вопросы

1. Что такое дерево? \
Дерево – это нелинейная структура данных, используемая для представления
иерархических связей, имеющих отношение «один ко многим».
2. Как выделяется память под представление деревьев? \
Если дерево имеет списочную структуру, то память под его узлы выделяет
в динамической памяти каждый раз при создании нового узла.
3. Какие стандартные операции возможны над деревьями? \
Обход вершин, поиск по дереву, включение узла в дерево, удаление узла.
4. Что такое дерево двоичного поиска? \
Это такое дерево, в котором левые потомки предка меньше его, а правые - больше.
5. Чем отличается идеально сбалансированное дерево от АВЛ дерева? \
ИСД - это частный случай АВЛ дерева, но с более жёстким требованием: количество
вершин в правом и левом поддереве отличается не более, чем на 1.
6. Чем отличается поиск в АВЛ-дереве от поиска в дереве двоичного поиска? \
Алгоритм не отличается, однако время поиска в АВЛ дереве меньше, из-за меньшей
высоты.
7. Что такое хеш-таблица, каков принцип её построения? \
Хеш таблица - это массив определённый хеш функцией.
8. Что такое коллизии? Каковы методы их устранения. \
Коллизия - это случай, когда разным ключам соответствует одно значение
хеш функции. Для их устранения используются открытое и закрытое хеширование.
9. В каком случае поиск в хеш-таблицах становится неэффективен? \
При большом числе коллизий.
10. Эффективность поиска в АВЛ деревьях, в дереве двоичного поиска и в
хеш таблицах. \
Поиск в хеш таблице занимает меньше времени, чем в деревьях, и в идеальном
случае находит нужную ячейку за одно сравнение. Поиск в АВЛ дерево эффективнее,
чем в ДДП, так как АВЛ дерево имеет в имеет в среднем меньшую высоту.
