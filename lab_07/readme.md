# Отчёт по Лабораторной работе №7 "Графы"

Вариант: 4

Студент: **Недолужко Денис**

Группа: **ИУ7-33Б**

Год: 2020

## Описание условия задачи

Цель работы – реализовать алгоритмы обработки графовых структур:
поиск различных путей, проверку связности, построение остовых деревьев
минимальной стоимости.

## Описание ТЗ

### Описание задачи

Найти все вершины графа, к которым от заданной вершины можно добраться по пути
не длиннее А.

### Входные данные

Граф вводится в формате: `<Начальная вершина> <Конечная вершина> <Вес ребра>`.
Данные такого формата вводятся вручную или из файла.

### Выходные данные

Изображение графа, где исходная вершина жёлтого цвета, а вершины, до которых
можно добрать по пути не длиннее А - зелёные.

### Способ обращения к программе

Запускается в терминале командой `./app.exe` в папке с программой.

### Описание возможных аварийных ситуаций

Некорректный ввод пользователя. Сообщение `Некорректный ввод`.
Невозможность выделения памяти под переменные `Невозможно выделить память под
переменную`
Невозможно открыть файл `Файл не найден`.

## Описание внутренний структур данных

```c
struct graph_edge
{
    unsigned src;
    unsigned dst;
    int weight;

    struct list_head list;
};

struct graph
{
    struct list_head list;
    unsigned graph_node_count;
};
```

Структуры представляющие граф:
* struct graph\_edge - ребро графа
* struct graph - граф

* list - список рёбер графа
* graph\_node\_count - число узлов графа
* src - начальный узел
* dst - конечный узел
* weight - вес ребра

---

```c
struct list_head
{
    struct list_head *next, *prev;
};
```

Структура, реализующая список, являясь полем исходной структуры

---

```c
typedef struct
{
    void *elements;
    size_t length;

    size_t el_size;
} vector_t;

struct graph_way_weight
{
    unsigned name;
    int way_weight;
};
```

Структура вектора, хранящего веса путей от вершины А до других.

* elements - массив
* length - длина массива
* el\_size - размер элемента массива
* name - название узла
* way\_weight - вес пути до него

## Описание функций

Создание и освобождение графа

```c
struct graph *graph_init();
void graph_free(struct graph *graph);
```

Добавление нового ребра в граф

```c
int graph_add_node(struct graph *graph, unsigned src, unsigned int dst, int weight);
int graph_add_node_from_file(struct graph *graph, char *filename);
```

Вывод графа

```c
void graph_print(struct graph *graph);
int graph_draw(struct graph *graph);
int graph_draw_and_select(struct graph *graph, vector_t *vector, int weight, unsigned start_name);
```

Поиск узлом с весом пути по А

```c
int graph_bellman_ford_mod(struct graph *graph, vector_t **vector, unsigned start_name);
```

## Описание алгоритма

Задачей является: нахождение вершин, к которым можно добраться от заданной
вершины по пути не длиннее А. Задача не ставит ограничение на отрицательный вес
рёбер, поэтому используем модифицированный алгоритм Беллмана-Форда.

1. Инициализируем массив длин бесконечными длинами, а ячейку исходного
узла - нулём.
2. В цикле `V - 1` раз проходится по всем рёбрам графа
(где V - число узлов графа.). И изменяем значения длин в массиве, если
при прохождении через данное ребро получаем меньший вес.
3. На данном этапе происходит расхождение к классическим алгоритмом
Беллмана-Форда. В случае наличия циклов, дающий отрицательный вес алгоритм
прекращает работу. Модификация заключается в том, чтобы сохранить полученные
значения, а продолжать работать с их копией. Повторяем шаг 2, только `V` раз.
Теперь если значение исходного массива отличается от нового, это означает, что
мы может попасть в данный узел после прохождения через цикл с отрицательной
длиной. Следовательно мы может получать сколь угодно малую длину пути для этого
узла, поэтому изменил значение пути до него на -бесконечную длину.

### Оценка памяти

Память выделяется под ребра графов и под массив длин путей до элементов.

### Оценка времени

`O(N * 2V)`, где N - число рёбер графа, V - число узлов графа.

## Вывод

Граф представляется в виде списка рёбер. Это позволяет добавлять ребра графа
без реалокации массив. Так же доступ с отдельным узлам по индексу
не требуется для алгоритма.

В качестве алгоритма используется модифицированный алгоритм Беллмана-Форда,
так как он, в отличии от алгоритма Дейкстры, позволяет работать от
отрицательными длинами рёбер.

Задача где может использоваться данный алгоритм: определение городов, в которые
можно доехать из данной точки с определённым количеством бензина, и со
значением о расположении заправок на дороге.

## Вопросы

1. Что такое граф? \
Граф - это конечное множество вершин и рёбер, соединяющих их.
2. Как представляются графы в памяти? \
В виде таблицы смежности, массива рёбер и списка достижимых вершин из каждой
вершины.
3. Какие операции возможны над графами? \
- поиск вершин в графе
- поиск кратчайших путей от Vk до Vm
- поиск Эйлерова пути
- поиск Гамильтонова пути
- поиск кратчайших путей между всеми вершинами
4. Какие способы обхода графов существуют? \
В глубину, и в ширину.
5. Где используются графовые структуры? \
Схемы дорог, метро, авиалиний.
6. Какие пути в графе Вы знаете? \
Простой, гальмитонов, эйлеров, замкнутый.
7. Что такое каркасы графа? \
Каркас графа - это граф с тем же числом узлов, с минимальным число рёбер, без
нарушения связности графа.
