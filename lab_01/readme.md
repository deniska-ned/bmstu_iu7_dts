# Отчет по Лабораторной работе №1 "Длинная арифметика"

Студент: **Недолужко Денис**

Группа: **ИУ7-33Б**

Год: 2020

## Описание условия задачи

Смоделировать операцию умножения действительного числа
на действительное число в форме `±m.n Е ±K`, где
суммарная длина мантиссы `(m + n)` - до 30 значащих цифр, а
величина порядка K - до 5 цифр. Результат выдать в форме
`±0.m1 Е ±K1`, где m1 - до 30 значащих цифр, а K1 - до 5
цифр.

Десятичное число может представляться без точки: 123, при наличии десятичной
точки в числе возможны следующие варианты его представления: `.00025`,
`+123001.`, `-123.456`. Также допускается представление числа в экспоненциальной
форме: `1234567 Е –20`, `1234567 Е 20` или `123.4567 Е23`.

Если при умножении или делении чисел длина мантиссы стала больше 30
знаков, то необходимо произвести округление (если 31-й разряд больше или равен
5, Жто к 30-му разряду добавляется единица, если меньше 5, то 31-й разряд
отбрасывается). При этом может возникнуть циклический поразрядный перенос из
младшего разряда в старший с коррекцией порядка.

При разработке интерфейса программы следует предусмотреть:

* указание операции, производимой программой;
* указание формата и диапазона вводимых данных;
* указание формата выводимых данных;
* наличие пояснений при выводе результата.

## Техническое задание

### Входные данных

2 строки, содержащие число в вещественной форме `±m.n Е ±K`. Знак экспоненты `E`
вводится только в верхнем регистре. Суммарная длина `(m + n)` - до 30 символов
включительно, длина порядка - до 5 цифр.  Знак перед числом, если это `+` может
быть опущен. Дробная часть числа может быть опущена. Порядок вместе с символом
экспоненты могут быть опущены.

### Выходные данные

Строка в виде `первый_множитель * второй множитель = произведение`, где каждое
из чисел представлено в виде `±0.mЕ±K`. Длина мантиссы `m` до 30 цифр
включительно, длина порядка `K` до по 5 цифр включительно. Знак `+` опускается.

### Описание задачи, реализуемой программой

Перемножение вещественных чисел.

### Способ обращения к программе

Запускается в терминале командой `./app.out` в папке с программой.

### Описание возможных аварийных ситуаций и ошибок пользователя

1. Знак числа стоит в недопустимом месте.
Вывод сообщения "Incorrect sign position"
1. В порядке поставлена точка. Вывод сообщения "Dot in power found"
1. В числе встречено больше одной точки. Вывод сообщения "Incorrect dot count"
1. В числе встречено больше двух знаков экспоненты.
Вывод сообщения "Incorrect e count"
1. В числе встречен недопустимый символ. Вывод сообщения "Incorrect symbol"
1. В числе отсутствует мантисса. Вывод сообщения "Absence of mantissa"
1. Превышена допустимая длина мантиссы.
Вывод сообщения "Max mantissa len exceeded"
1. Отсутствует порядок после знака экспоненты.
Вывод сообщения "Absence of expected power"
1. Превышена допустимая длина порядка. Вывод сообщения "Max power len exceeded"
1. Превышено допустимое число символов при вводе числа.
Вывод сообщения "Char num exceeded"
1. Длина порядка произведения превышает допустимое значение.
Вывод сообщения "Product power length exceeded"
1. Неизвестная ошибка. Вывод сообщения "Unknown error"

## Описание внутренних структур данных

Число записывается и хранится в структуре `big_decimal_t`

```c
struct big_decimal {
    int8_t mantissa_sign;
    int8_t mantissa[MAX_MANTISSA_LEN];
    int32_t power;
};

typedef struct big_decimal big_decimal_t;
```

Поля структуры:

* `mantiisa_sign` - знак мантиссы, принимает значения перечисления num
* `mantissa[MAX_MANTISSA_LEN]` - мантисса числа
* `power` - значение порядка

```c
#define MAX_MANTISSA_LEN 30

enum num_sign {
    POSITIVE = 1,
    NEGATIVE = -1
};
```

## Описание алгоритма

1. Программа считывает 2 строки, содержащие числа \
`int input_source_numbers(big_decimal_t *const first_num, big_decimal_t *const
second_num);`
1. Далее строки преобразуются в структуру `big_decimal_t` представляющие числа \
`int str_to_big_decimal(const char *const str, big_decimal_t *const num)`
1. Затем числа передаются в функцию умножения, в которой создается массив
максимальной возможной длины числа и производится умножение по принципу
умножения в столбик, при необходимости - округление \
`int big_decimal_multiplication(const big_decimal_t num_1, const big_decimal_t
num_2, big_decimal_t *const product);`
1. Затем результат умножения выводится на экран \
`void print_multiplication_result(const big_decimal_t first_num,
const big_decimal_t second_num, const big_decimal_t result)`

### Функции программы

```C
int check_str(const char *const str);
```

Описание:

Проверка на то, может ли строка быть представлена в виде
`big_decimal_t`

Входные данные:

* str - строка

Выходные данные:

* (return code) OKAY - если преобразвоание возможно
* (return code) INCORRECT_SIGN_POSITION - если знак находится на некорректной
позиции;
* (return code) DOT_IN_POWER_FOUND - если точка встречена в порядке;
* (return code) INCORRECT_DOT_COUNT - если число строк больше 1;
* (return code) INCORRECT_E_COUNT - если число знаков эспоненты больше 1;
* (return code) INCORRECT_SYMBOL - если встречен недопустимый символ;
* (return code) ABSENCE_OF_MANTISSA - если мантисса отсутствует;
* (return code) MAX_MANTISSA_LEN_EXCEEDED - если превышена максимальная длина
мантиссы;
* (return code) ABSENCE_OF_EXPECTED_POWER - если отсутствует порядок;
* (return code) MAX_POWER_LEN_EXCEEDED - если длина порядка больше допустимой.

```C
int str_to_big_decimal(const char *const str, big_decimal_t *const num);
```

Описание:

Перед строки с `big_decimal_t`

Входные данные:

* str - Строка для передачи

Выходные данные:

* num - указатель на число
* (return code) OKAY - если преобразвоание возможно
* (return code) INCORRECT_SIGN_POSITION - если знак находится на некорректной
позиции;
* (return code) DOT_IN_POWER_FOUND - если точка встречена в порядке;
* (return code) INCORRECT_DOT_COUNT - если число строк больше 1;
* (return code) INCORRECT_E_COUNT - если число знаков эспоненты больше 1;
* (return code) INCORRECT_SYMBOL - если встречен недопустимый символ;
* (return code) ABSENCE_OF_MANTISSA - если мантисса отсутствует;
* (return code) MAX_MANTISSA_LEN_EXCEEDED - если превышена максимальная длина
мантиссы;
* (return code) ABSENCE_OF_EXPECTED_POWER - если отсутствует порядок;
* (return code) MAX_POWER_LEN_EXCEEDED - если длина порядка больше допустимой.

```C
int input_source_numbers(big_decimal_t *const first_num,
big_decimal_t *const second_num);
```

Описание:

Ввод чисел с консоли

Входные данные:

Посимвольное чтение с консоли

Выходные данные:

* first_num - указатель на первое число
* second_num - указатель на второе число
* (return code) OKAY - если преобразвоание возможно
* (return code) INCORRECT_SIGN_POSITION - если знак находится на некорректной
позиции;
* (return code) DOT_IN_POWER_FOUND - если точка встречена в порядке;
* (return code) INCORRECT_DOT_COUNT - если число строк больше 1;
* (return code) INCORRECT_E_COUNT - если число знаков эспоненты больше 1;
* (return code) INCORRECT_SYMBOL - если встречен недопустимый символ;
* (return code) ABSENCE_OF_MANTISSA - если мантисса отсутствует;
* (return code) MAX_MANTISSA_LEN_EXCEEDED - если превышена максимальная длина
мантиссы;
* (return code) ABSENCE_OF_EXPECTED_POWER - если отсутствует порядок;
* (return code) MAX_POWER_LEN_EXCEEDED - если длина порядка больше допустимой;
* (return code) CHAR_NUM_EXCEED - если превышена допустимая длина строки.

```C
void big_decimal_to_str(const big_decimal_t  num, char *const str);
```

Описание:

Преобразование строки в число

Входные данные:

* num - число

Выходные данные:

* str - строка для ввода

```C
void print_multiplication_result(const big_decimal_t first_num,
const big_decimal_t second_num, const big_decimal_t result);
```

Описание:

Вывод результата в консоль

Входные данные:

* first_num - первый множитель
* second_num - второй множитель
* product - произведение

Выходные данные:

Вывод произведение в консоль

```C
int big_decimal_multiplication(const big_decimal_t num_1,
const big_decimal_t num_2, big_decimal_t *const product);
```

Описание:

Произведение чисел

Входные данные:

* num_1 - первое число
* num_2 - второе число

Выходные данные:

* product - произведение
* (return code) OKAY - если нет ошибки
* (return code) PRODUCT_POWER_LEN_EXCEEDED - если превышена длина порядка
произведения

```C
int is_big_decimal_zero(const big_decimal_t num);
```

Описание:

Проверка. Является ли `num` нулем.

Входные данные:

* num - число

Выходные данные:

* (return code) TRUE - является
* (return code) FALSE - не является

## Набор тестов

### Негативные тесты

|Описание|Число 1|Число 2|Вывод|
|-|-|-|-|
|Некорректная позиция знака|0.+12E0|2.0E0|Incorrect sign position|
|Точка в порядке|0.12E11.0|2.0E0|Dot in power found|
|Больше одной точки|0.1.2E0|2.0E0|Incorrect dot count|
|Некорректный символ|c0.12E0|2.0E0|Incorrect symbol|
|Отсутствие мантиссы|E10|2.0E0|Absence of mantissa|
|Длина мантиссы превышена|1234567890123456789012345678901E0|2.0E0|Max mantissa len exceeded|
|Отсутствие порядка после E|0.12E|2.0E0|Absence of expecred power|
|Длина порядка превышена|0.12E123456|2.0E0|Max power len exceeded|
|Превышена длина строки|1234567890123456789012345678901234567E90|2.0E0|Char num exceeded|
|Длина порядка произведения превышена|0.12E99999|0.1E099999|Product power length exceeded|
|Длина порядка произведения превышена 2|10E99999|1|Product power length exceeded|

### Позитивные тесты

|Описание|Число 1|Число 2|Вывод|
|-|-|-|-|
|Обычное умножение|0.12E0|2.0E0|0.24E0|
|Число со знаком минус|-0.12E0|2.0E0|-0.24E0|
|Число со знаком плюс|0.12E0|+2.0E0|0.24E0|
|Порядок со знаком плюс|0.12E0|0.2E+1|0.24E0|
|Порядок со знаком минус|0.12E0|20E-1|0.24E0|
|Мантисса без точки|0.12E0|2E0|0.24E0|
|Число без порядка|0.12E0|2|0.24E0|
|Умножение на ноль|0.12E0|0|0.0E0|
|Максимальная длина мантиссы|123456789012345678901234567890E0|1|0.123456789012345678901234567890|
|Максимальная длина порядка|0.12E99999|1E-10|0.12E99989|
|Превышение 30 знаков произведенея|777777777777777777777777777777|5|0.388888888888888888888888888889E31|
|Циклическое округление|999999999999999999999999999999|2|0.2E31|
|Множитель с длиной порядка больше 5|10E99999|0.01|0.1E99999|

## Выводы по проделанной работе

Была реализованная программа производящая операцию умножения на 2х
действительных числел в форме `±m.n Е ±K`, где
суммарная длина мантиссы `(m + n)` - до 30 значащих цифр, а
величина порядка K - до 5 цифр.
При необходимости программа может производит умножение вещественных чисел
любой точности.

## Контрольные вопросы

1. Каков возможный диапазон чисел, представляемых в ПК?\
Максимальное значение беззаконного целого числа, для которого выделяется 64
разряда, равно `2^64 = 18 446 744 073 709 551 615`.
Диапазон чисел зависит от выбранного типа, разрядности процессора и памяти
выделенной для хранения числа.
2. Какова возможная точность представления чисел, чем она определяется?\
Память, выделяемая под хранение мантиссы числа, определяет точность
представления вещественных чисел. Для мантиссы числа типа double выделяется 52
бита, с помощью этого мантисса числа может иметь значение до
`4 503 599 627 370 496`.
3. Какие стандартные операции возможны над числами?
    * Сложение
    * Вычитание
    * Умножение
    * Деление
    * Сравнение
4. Какой тип данных может выбрать программист, если обрабатываемые числа
превышают возможный диапазон представления чисел в ПК?\
Массив, или структура, в которой каждый символ числа будет храниться в некотором
типе
5. Как можно осуществить операции над числами, выходящими за рамки
машинного представления?\
Реализовать собственные функции или использовать существующие библиотеки для
работы с такими данным.
